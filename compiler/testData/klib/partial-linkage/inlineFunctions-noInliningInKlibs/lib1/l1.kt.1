@file:Suppress("NOTHING_TO_INLINE")

/**************************************************/
/***** Extracted from 'classTransformations': *****/
/**************************************************/

class Class {
    fun f() = "Class.f"
    val p get() = "Class.p"
    override fun toString() = "Class"
}

enum class ClassToEnum {
    Foo,
    Bar,
    Baz
}

enum class ObjectToEnum {
    Foo,
    Bar
}

class EnumToClass {
    class Foo
    object Bar
    inner class Baz
}

object EnumToObject {
    class Foo
    object Bar
}

object ClassToObject
class ObjectToClass

interface ClassToInterface

class NestedObjectToCompanion1 {
    companion object {
        fun name() = "NestedObjectToCompanion1.Companion"
        override fun toString() = name()
    }
}

class NestedObjectToCompanion2 {
    companion object Foo {
        fun name() = "NestedObjectToCompanion2.Foo"
        override fun toString() = name()
    }
}

class CompanionToNestedObject1 {
    object Companion {
        fun name() = "CompanionToNestedObject1.Companion"
        override fun toString() = name()
    }
}

class CompanionToNestedObject2 {
    object Foo {
        fun name() = "CompanionToNestedObject2.Foo"
        override fun toString() = name()
    }
}

class CompanionAndNestedObjectsSwap {
    object Foo {
        fun name() = "Foo"
    }

    companion object Bar {
        fun name() = "Bar"
    }
}

class NestedClassContainer {
    fun name() = "NestedClassContainer"

    inner class NestedToInner {
        fun name() = this@NestedClassContainer.name() + ".NestedToInner"
        override fun toString() = name()

        inner class /*object*/ Object {
            fun name() = this@NestedToInner.name() + ".Object"
            override fun toString() = name()
        }

        inner class /*companion object*/ Companion {
            fun name() = this@NestedToInner.name() + ".Companion"
            override fun toString() = name()
        }

        inner class /*class*/ Nested {
            fun name() = this@NestedToInner.name() + ".Nested"
            override fun toString() = name()
        }

        inner class Inner {
            fun name() = this@NestedToInner.name() + ".Inner"
            override fun toString() = name()
        }
    }
}

class InnerClassContainer {
    fun name() = "InnerClassContainer"

    class InnerToNested {
        fun name() = "InnerClassContainer.InnerToNested"
        override fun toString() = name()

        object Object {
            fun name() = "InnerClassContainer.InnerToNested.Companion"
            override fun toString() = name()
        }

        companion object Companion {
            fun name() = "InnerClassContainer.InnerToNested.Companion"
            override fun toString() = name()
        }

        class Nested {
            fun name() = "InnerClassContainer.InnerToNested.Nested"
            override fun toString() = name()
        }

        inner class Inner {
            fun name() = this@InnerToNested.name() + ".Inner"
            override fun toString() = name()
        }
    }
}

annotation class AnnotationClassWithChangedParameterType(val x: /*Int*/ String)
/*annotation*/ class AnnotationClassThatBecomesRegularClass(val x: Int) { override fun toString() = "AnnotationClassThatBecomesRegularClass[x=$x]" }
//annotation class AnnotationClassThatDisappears(val x: Int)
annotation class AnnotationClassWithRenamedParameters(val xi: Int, val xs: String)
annotation class AnnotationClassWithReorderedParameters(val s: String, val i: Int)
annotation class AnnotationClassWithNewParameter(val i: Int, val s: String = "Apple")

class ValueToClass(val x: Int)
value class ClassToValue(val x: Int)

/*data*/ class DataToClass(val x: Int, val y: Int)

abstract class ClassToAbstractClass {
    abstract var name: String
    fun getGreeting() = "Hello, $name!"
}

//class RemovedClass {
//    fun f() = "FAIL: RemovedClass.f"
//    val p get() = "FAIL: RemovedClass.p"
//}
enum class EnumClassWithDisappearingEntry { UNCHANGED, /*REMOVED*/ }

object PublicTopLevelLib1 {
    private annotation class AnnotationClassThatBecomesPrivate
    private class ClassThatBecomesPrivate
    private enum class EnumClassThatBecomesPrivate { ENTRY }
}

interface XAnswer { fun answer(): Int }
interface XAnswerDefault { fun answer(): Int /*= 42*/ }
interface XFunction1 { fun function1(): Int }
interface XFunction1Default { fun function1(): Int = 42 }
interface XFunction2 { fun function2(): Int }
interface XFunction2Default { fun function2(): Int = -42 }
interface XProperty1 { val property1: Int }
interface XProperty1Default { val property1: Int get() = 42 }
interface XProperty2 { val property2: Int }
interface XProperty2Default { val property2: Int get() = 42 }

/*fun*/ interface FunctionalInterfaceToInterface : XAnswer

/*****************************************************/
/***** Extracted from 'functionTransformations': *****/
/*****************************************************/

object Functions {
    @Suppress("RedundantSuspendModifier") suspend fun <R> wrapCoroutine(coroutine: suspend () -> R): R = coroutine.invoke()
    fun suspendToNonSuspendFunction(x: Int): Int = -x
    suspend fun nonSuspendToSuspendFunction(x: Int): Int = wrapCoroutine { -x }

    inline fun inlineLambdaToNoinlineLambda(x: Int, noinline lambda: (Int) -> String): String = "Functions.inlineLambdaToNoinlineLambda($x) { ${lambda(x * 2)} }"
    inline fun inlineLambdaToCrossinlineLambda(x: Int, crossinline lambda: (Int) -> String): String = "Functions.inlineLambdaToCrossinlineLambda($x) { ${lambda(x * 2)} }"
}

open class OpenClass {
    inline fun openNonInlineToInlineFunction(x: Int): String = "OpenClassV2.openNonInlineToInlineFunction($x)"
    inline fun openNonInlineToInlineFunctionWithDelegation(x: Int): String = "OpenClassV2.openNonInlineToInlineFunctionWithDelegation($x)"
    inline fun newInlineFunction1(x: Int): String = "OpenClassV2.newInlineFunction1($x)"
    inline fun newInlineFunction2(x: Int): String = "OpenClassV2.newInlineFunction2($x)"
    fun newNonInlineFunction(x: Int): String = "OpenClassV2.newNonInlineFunction($x)"

    fun newInlineFunction1Caller(x: Int): String = newInlineFunction1(x)
    fun newInlineFunction2Caller(x: Int): String = newInlineFunction2(x)
    fun newNonInlineFunctionCaller(x: Int): String = newNonInlineFunction(x)
}

/********************************************/
/***** Extracted from 'removeCallable': *****/
/********************************************/

//fun removedFunction(): String = "FAIL: removedFunction"
//val removedProperty: String get() = "FAIL: removedProperty"

/*****************************************/
/***** Extracted from 'removeClass': *****/
/*****************************************/

//abstract class RemovedAbstractClass
//interface RemovedInterface

//open class RemovedOpenClass
